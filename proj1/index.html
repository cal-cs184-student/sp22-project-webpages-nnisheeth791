<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184 Rasterizer</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2022</h1>
<h1 align="middle">Project 1: Rasterizer</h1>
<h2 align="middle">Naman Nisheeth (SID: 3034144312) and Owen Gong (SID: 3034100450),</h2>

<br><br>

<div>

<h2 align="middle">Overview</h2>
<p>We learned a lot from this project since it was our first time doing a project related to computer graphics. Implementing this rasterizer was a good
  first step into the world of graphics. We built many different levels of a rasterizer ranging from doing single-colored pixels to supersampling to laying a texture
  on various pictures including the Berkeley seal and a world map. This project was really enlightening for us because it gave me more insight onto something
  that we usually take for granted- computer generated images and textures. We learned a lot of interesting things from this project like implementing supersampling
  which allows for better clarity of an image or texture mapping which is not nearly as complicated as we once previously thought it would be.</p>

<h2 align="middle">Section I: Rasterization</h2>

<h3 align="middle">Part 1: Rasterizing single-color triangles</h3>

  <p>Our first step in this project was rasterizing triangles. We did this by using sampling methods that we learned in class. For this particular part,
  we checked to see if the center of a pixel was located withing the triangle outline and if it was, we would color it in. To check if a pixel was 
  located inside the triangle outline, we had to calculate the line equations of the triangle. We then used point-in-line tests to determine whether the point
  in question did in fact fall inside all 3 lines of the triangle. We did this while checking both the clockwise and counterclockwise orientations 
  of the vertices. Our algorithm is no worse than one that checks each sample within the bounding box of a triangle because in our rasterize_triangle, our two
  outer for loops iterate through the minimum X value of the triangle and the maximum X value of the triangle for the width. For the height it iterates through
  the minimum Y value and the maximum Y value of the triangle for the height. This is sampling every point of the bounding rectangle that the triangle resides 
  in.</p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="test4.png" align="middle" width="400px"/>
        <figcaption align="middle">Examining the corner of the blue triangle</figcaption>
      </td>
    </tr>
  </table>
</div>


<h3 align="middle">Part 2: Antialiasing triangles</h3>
  
  <p>In this task of the project, we implemented supersampling. Since supersampling is dependent on the sampling rate, we had to implement additional 
  for loops in order to check inside each of the pixels based on how many times we wanted to sample them. Since all the subpixels are also
  squares, the <strong>number</strong> of subpixels in a pixel has to be a perfect square. Supersampling is useful because it provides a more accurate result 
  than just sampling once. It provides a higher image resolution and reduces aliasing. As mentioned earlier, we updated the rasterization pipeline to 
  account for sampling rates that are greater than 1 (but also have to be square values) which meant that we needed to calculate the center of each pixel
  based on the sampling rate rather than just using 1. Supersampling promotes antialiasing because it takes <strong>several</strong> color samples from a pixel and averages them
  to one color based on the location of pixel in the image. This provides a clearer image than having one color represent a whole image and increasing the risk of
  aliasing.</p>
  
  <div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="task4_1.png" align="middle" width="400px"/>
        <figcaption align="middle">Sample Rate: 1</figcaption>
      </td>
      <td>
        <img src="task4_4.png" align="middle" width="400px"/>
        <figcaption align="middle">Sample Rate: 4</figcaption>
      </td>
    <br>
      <tr>
      <td>
        <img src="task4_16.png" align="middle" width="400px"/>
        <figcaption align="middle">Sample Rate: 16</figcaption>
      </td>
    </tr>
  </table>
</div>



<h3 align="middle">Part 3: Transforms</h3>
  <p>This is the modified robot that we made. In this image, this robot is more colorful and is doing a little dancey dance similar to a disco. Very pog.</p>



<h2 align="middle">Section II: Sampling</h2>

<h3 align="middle">Part 4: Barycentric coordinates</h3>


<h3 align="middle">Part 5: "Pixel sampling" for texture mapping</h3>


<h3 align="middle">Part 6: "Level sampling" with mipmaps for texture mapping</h3>



<h2 align="middle">Section III: Art Competition</h2>
<p>If you are not participating in the optional art competition, don't worry about this section!</p>

<h3 align="middle">Part 7: Draw something interesting!</h3>

</body>
</html>
